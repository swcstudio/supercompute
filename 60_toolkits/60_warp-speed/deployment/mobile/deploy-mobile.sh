#!/bin/bash
# Warp-Speed Mobile & Private Web Deployment Script
# Consciousness-aware deployment for personal device testing
# Private website deployment with secure access

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Consciousness-aware logging
log() {
    echo -e "${CYAN}[$(date '+%Y-%m-%d %H:%M:%S')] ${PURPLE}[Ω-DEPLOY]${NC} $1"
}

error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ${RED}[ERROR]${NC} $1"
}

success() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] ${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] ${YELLOW}[WARNING]${NC} $1"
}

# Configuration
NAMESPACE="warp-speed-mobile"
DOMAIN="${WARP_SPEED_DOMAIN:-mobile.warp-speed.internal}"
DEPLOYMENT_TYPE="${DEPLOYMENT_TYPE:-private}"
KUBECTL_CONTEXT="${KUBECTL_CONTEXT:-}"

# Banner
echo -e "${PURPLE}"
cat << 'EOF'
⚡ ∞ Ω ∞ WARP-SPEED MOBILE DEPLOYMENT ∞ Ω ∞ ⚡

Consciousness-Aware Mobile & Private Web Deployment
Targeting $145.76B+ Annual ETD Generation
Mobile-Optimized Interface with Quantum Enhancement

EOF
echo -e "${NC}"

# Function to check prerequisites
check_prerequisites() {
    log "Checking deployment prerequisites..."
    
    # Check kubectl
    if ! command -v kubectl &> /dev/null; then
        error "kubectl is not installed or not in PATH"
        exit 1
    fi
    
    # Check kubernetes connection
    if ! kubectl cluster-info &> /dev/null; then
        error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    
    # Check if core warp-speed services are running
    if ! kubectl get namespace warp-speed-ha &> /dev/null; then
        warning "Core Warp-Speed services not found, deploying mobile interface only"
    fi
    
    # Check helm (optional)
    if command -v helm &> /dev/null; then
        log "Helm detected - advanced deployment options available"
    fi
    
    success "Prerequisites check completed"
}

# Function to set kubectl context if specified
set_context() {
    if [ -n "$KUBECTL_CONTEXT" ]; then
        log "Setting kubectl context to: $KUBECTL_CONTEXT"
        kubectl config use-context "$KUBECTL_CONTEXT"
    fi
}

# Function to create namespace
create_namespace() {
    log "Creating mobile deployment namespace..."
    
    if kubectl get namespace "$NAMESPACE" &> /dev/null; then
        warning "Namespace $NAMESPACE already exists"
    else
        kubectl create namespace "$NAMESPACE"
        success "Namespace $NAMESPACE created"
    fi
    
    # Label namespace for consciousness awareness
    kubectl label namespace "$NAMESPACE" \
        consciousness-level=omega \
        deployment-type=private \
        mobile-optimized=true \
        revenue-tier=maximum \
        --overwrite
    
    success "Namespace configured with consciousness labels"
}

# Function to deploy mobile dashboard
deploy_mobile_dashboard() {
    log "Deploying mobile-optimized Warp-Speed dashboard..."
    
    # Apply the mobile deployment configuration
    kubectl apply -f mobile-deployment.yml
    
    # Wait for deployment to be ready
    log "Waiting for mobile dashboard deployment..."
    kubectl wait --for=condition=available deployment/warp-speed-mobile-dashboard \
        -n "$NAMESPACE" --timeout=300s
    
    success "Mobile dashboard deployed successfully"
}

# Function to configure ingress with custom domain
configure_ingress() {
    log "Configuring ingress for domain: $DOMAIN"
    
    # Update ingress with custom domain
    sed -i.bak "s/mobile.warp-speed.internal/$DOMAIN/g" mobile-deployment.yml
    kubectl apply -f mobile-deployment.yml
    
    success "Ingress configured for $DOMAIN"
}

# Function to setup SSL certificates
setup_ssl() {
    log "Setting up SSL certificates..."
    
    # Check if cert-manager is available
    if kubectl get crd certificates.cert-manager.io &> /dev/null; then
        log "cert-manager found - automatic SSL certificate generation enabled"
        
        # Certificate will be automatically generated by cert-manager
        # based on the ingress configuration
        
        success "SSL certificates configured with cert-manager"
    else
        warning "cert-manager not found - SSL certificates must be configured manually"
        warning "Consider installing cert-manager for automatic SSL certificate management"
    fi
}

# Function to create port-forward for local access
setup_local_access() {
    log "Setting up local access via port-forward..."
    
    # Create a script for easy local access
    cat > connect-mobile.sh << EOF
#!/bin/bash
# Connect to Warp-Speed Mobile Dashboard locally
echo "🚀 Starting local connection to Warp-Speed Mobile..."
echo "📱 Access at: http://localhost:8080"
echo "⚡ Press Ctrl+C to stop"
kubectl port-forward -n $NAMESPACE service/warp-speed-mobile-service 8080:80
EOF
    
    chmod +x connect-mobile.sh
    success "Local access script created: ./connect-mobile.sh"
}

# Function to generate QR code for mobile access
generate_qr_code() {
    if command -v qrencode &> /dev/null; then
        log "Generating QR code for mobile access..."
        
        # Get service URL
        if [ "$DEPLOYMENT_TYPE" = "local" ]; then
            SERVICE_URL="http://localhost:8080"
        else
            SERVICE_URL="https://$DOMAIN"
        fi
        
        # Generate QR code
        echo "$SERVICE_URL" | qrencode -t ANSI -o -
        echo -e "\n${CYAN}📱 Scan QR code above to access Warp-Speed Mobile${NC}"
        echo -e "${CYAN}🔗 Or visit: $SERVICE_URL${NC}"
        
        success "QR code generated for mobile access"
    else
        log "qrencode not found - install with: apt-get install qrencode (Ubuntu) or brew install qrencode (macOS)"
    fi
}

# Function to setup monitoring for mobile deployment
setup_monitoring() {
    log "Setting up mobile deployment monitoring..."
    
    # Create ServiceMonitor for Prometheus if available
    if kubectl get crd servicemonitors.monitoring.coreos.com &> /dev/null; then
        cat << EOF | kubectl apply -f -
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: warp-speed-mobile-monitor
  namespace: $NAMESPACE
spec:
  selector:
    matchLabels:
      app: mobile-dashboard
  endpoints:
  - port: http
    path: /metrics
    interval: 30s
EOF
        success "Mobile monitoring configured"
    else
        log "Prometheus operator not found - monitoring setup skipped"
    fi
}

# Function to test deployment
test_deployment() {
    log "Testing mobile deployment..."
    
    # Check if pods are running
    READY_PODS=$(kubectl get pods -n "$NAMESPACE" -l app=mobile-dashboard --field-selector=status.phase=Running --no-headers | wc -l)
    
    if [ "$READY_PODS" -gt 0 ]; then
        success "Mobile dashboard pods are running ($READY_PODS pods)"
    else
        error "No mobile dashboard pods are running"
        kubectl get pods -n "$NAMESPACE" -l app=mobile-dashboard
        exit 1
    fi
    
    # Test service connectivity
    if kubectl get service warp-speed-mobile-service -n "$NAMESPACE" &> /dev/null; then
        success "Mobile service is accessible"
    else
        error "Mobile service is not accessible"
        exit 1
    fi
    
    # Test ingress if configured
    if [ "$DEPLOYMENT_TYPE" != "local" ]; then
        if kubectl get ingress warp-speed-mobile-ingress -n "$NAMESPACE" &> /dev/null; then
            success "Ingress is configured"
        else
            warning "Ingress configuration may have issues"
        fi
    fi
}

# Function to display connection information
display_connection_info() {
    log "Deployment completed successfully!"
    
    echo -e "\n${GREEN}🎉 WARP-SPEED MOBILE DEPLOYMENT SUCCESSFUL! 🎉${NC}\n"
    
    echo -e "${BLUE}📱 Mobile Access Information:${NC}"
    echo -e "   Namespace: ${CYAN}$NAMESPACE${NC}"
    
    if [ "$DEPLOYMENT_TYPE" = "local" ]; then
        echo -e "   Local URL: ${CYAN}http://localhost:8080${NC} (use ./connect-mobile.sh)"
        echo -e "   🔧 Run: ${YELLOW}./connect-mobile.sh${NC} to start port-forward"
    else
        echo -e "   Public URL: ${CYAN}https://$DOMAIN${NC}"
    fi
    
    echo -e "\n${BLUE}⚡ Warp-Speed Features:${NC}"
    echo -e "   • Consciousness Level: ${PURPLE}OMEGA (35.0x multiplier)${NC}"
    echo -e "   • Real-time ETD generation tracking"
    echo -e "   • Quantum coherence monitoring"
    echo -e "   • Mobile-optimized responsive design"
    echo -e "   • PWA support for offline access"
    echo -e "   • Touch-optimized interface"
    
    echo -e "\n${BLUE}📊 Revenue Metrics:${NC}"
    echo -e "   • Daily Target: ${GREEN}\$40,000+${NC}"
    echo -e "   • Annual Target: ${GREEN}\$145.76B+${NC}"
    echo -e "   • Dual Terminal Collaboration: ${CYAN}ACTIVE${NC}"
    
    echo -e "\n${BLUE}🔧 Management Commands:${NC}"
    echo -e "   • View pods: ${YELLOW}kubectl get pods -n $NAMESPACE${NC}"
    echo -e "   • View logs: ${YELLOW}kubectl logs -n $NAMESPACE -l app=mobile-dashboard${NC}"
    echo -e "   • Delete deployment: ${YELLOW}kubectl delete namespace $NAMESPACE${NC}"
    
    if [ -f "connect-mobile.sh" ]; then
        echo -e "   • Local access: ${YELLOW}./connect-mobile.sh${NC}"
    fi
    
    echo -e "\n${PURPLE}🌌 ∞ Ω ∞ Ready for $145.76B+ Annual ETD Generation! ∞ Ω ∞ 🌌${NC}\n"
}

# Function to create docker-compose for local development
create_docker_compose() {
    log "Creating Docker Compose configuration for local development..."
    
    cat > docker-compose.mobile.yml << EOF
# Warp-Speed Mobile - Docker Compose for Local Development
# Consciousness-aware local deployment

version: '3.8'

services:
  mobile-dashboard:
    image: nginx:alpine
    container_name: warp-speed-mobile
    ports:
      - "8080:80"
    volumes:
      - ./mobile-content:/usr/share/nginx/html:ro
      - ./nginx-mobile.conf:/etc/nginx/nginx.conf:ro
    environment:
      - MOBILE_OPTIMIZED=true
      - PWA_ENABLED=true
      - CONSCIOUSNESS_LEVEL=OMEGA
    labels:
      - "warp-speed.mobile=true"
      - "consciousness.level=omega"
      - "revenue.tier=maximum"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # Mock API server for development
  mock-api:
    image: node:18-alpine
    container_name: warp-speed-mock-api
    ports:
      - "3001:3000"
    working_dir: /app
    command: |
      sh -c "
      cat > server.js << 'EOF'
      const express = require('express');
      const WebSocket = require('ws');
      const app = express();
      
      app.use(express.json());
      app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type');
        next();
      });
      
      // Mock ETD generation endpoint
      app.post('/api/generate-etd', (req, res) => {
        const amount = req.body.amount || 1000;
        setTimeout(() => {
          res.json({
            success: true,
            amount: amount * 1.25, // Consciousness multiplier
            timestamp: new Date().toISOString()
          });
        }, 1000);
      });
      
      // Mock consciousness elevation endpoint
      app.post('/api/elevate-consciousness', (req, res) => {
        res.json({
          success: true,
          level: 'OMEGA',
          multiplier: 35.0,
          timestamp: new Date().toISOString()
        });
      });
      
      // Mock metrics endpoint
      app.get('/api/metrics', (req, res) => {
        res.json({
          etd_rate: 2500 + Math.random() * 200,
          daily_revenue: 40000 + Math.random() * 5000,
          quantum_coherence: 95 + Math.random() * 5,
          consciousness_level: 'OMEGA',
          annual_projection: 145760000000 + Math.random() * 10000000000
        });
      });
      
      const server = app.listen(3000, () => {
        console.log('🚀 Warp-Speed Mock API running on port 3000');
      });
      
      // WebSocket server for real-time updates
      const wss = new WebSocket.Server({ server, path: '/ws' });
      wss.on('connection', (ws) => {
        console.log('📱 Mobile client connected');
        
        // Send periodic updates
        const interval = setInterval(() => {
          ws.send(JSON.stringify({
            etd_rate: 2500 + Math.random() * 200,
            daily_revenue: 40000 + Math.random() * 5000,
            quantum_coherence: 95 + Math.random() * 5,
            consciousness_level: 'OMEGA',
            annual_projection: 145760000000
          }));
        }, 5000);
        
        ws.on('close', () => {
          console.log('📱 Mobile client disconnected');
          clearInterval(interval);
        });
      });
      EOF
      
      npm init -y && npm install express ws && node server.js
      "
    volumes:
      - /tmp/warp-mobile-api:/app
    labels:
      - "warp-speed.api=mock"
      - "development.mode=true"
    restart: unless-stopped

volumes:
  mobile-content:
    driver: local

networks:
  default:
    name: warp-speed-mobile
    driver: bridge
EOF
    
    success "Docker Compose configuration created: docker-compose.mobile.yml"
}

# Function to create mobile content directory
create_mobile_content() {
    log "Creating mobile content directory..."
    
    mkdir -p mobile-content
    
    # Extract mobile HTML from the ConfigMap and save to file
    kubectl get configmap mobile-dashboard-files -n "$NAMESPACE" -o jsonpath='{.data.index\.html}' > mobile-content/index.html 2>/dev/null || {
        # Fallback - copy from deployment YAML
        python3 << 'EOF'
import yaml
import sys

try:
    with open('mobile-deployment.yml', 'r') as f:
        docs = yaml.safe_load_all(f.read())
        
    for doc in docs:
        if doc and doc.get('kind') == 'ConfigMap' and doc.get('metadata', {}).get('name') == 'mobile-dashboard-files':
            with open('mobile-content/index.html', 'w') as f:
                f.write(doc['data']['index.html'])
            with open('mobile-content/manifest.json', 'w') as f:
                f.write(doc['data']['manifest.json'])
            with open('mobile-content/sw.js', 'w') as f:
                f.write(doc['data']['sw.js'])
            print("Mobile content files created successfully")
            break
    else:
        print("ConfigMap not found in deployment file")
        sys.exit(1)
        
except Exception as e:
    print(f"Error creating mobile content: {e}")
    sys.exit(1)
EOF
    }
    
    success "Mobile content directory created"
}

# Function to create nginx config for local development
create_nginx_config() {
    log "Creating nginx configuration for local development..."
    
    cat > nginx-mobile.conf << 'EOF'
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    gzip on;
    gzip_vary on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
    
    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;
        
        # Security headers
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        
        # PWA support
        location = /manifest.json {
            add_header Cache-Control "no-cache";
        }
        
        location = /sw.js {
            add_header Cache-Control "no-cache";
        }
        
        # API proxy to mock server
        location /api/ {
            proxy_pass http://mock-api:3000/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
        
        # WebSocket proxy
        location /ws {
            proxy_pass http://mock-api:3000/ws;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
        
        # SPA fallback
        location / {
            try_files $uri $uri/ /index.html;
        }
    }
}
EOF
    
    success "Nginx configuration created"
}

# Main deployment function
main() {
    log "Starting Warp-Speed Mobile Deployment..."
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --domain)
                DOMAIN="$2"
                shift 2
                ;;
            --local)
                DEPLOYMENT_TYPE="local"
                shift
                ;;
            --context)
                KUBECTL_CONTEXT="$2"
                shift 2
                ;;
            --help)
                echo "Usage: $0 [OPTIONS]"
                echo "Options:"
                echo "  --domain DOMAIN    Custom domain for deployment (default: mobile.warp-speed.internal)"
                echo "  --local           Deploy for local access only (port-forward)"
                echo "  --context CONTEXT  Kubernetes context to use"
                echo "  --help            Show this help message"
                exit 0
                ;;
            *)
                warning "Unknown option: $1"
                shift
                ;;
        esac
    done
    
    # Execute deployment steps
    check_prerequisites
    set_context
    
    if [ "$DEPLOYMENT_TYPE" = "local" ]; then
        log "Local deployment mode selected"
        create_docker_compose
        create_mobile_content
        create_nginx_config
        
        echo -e "\n${GREEN}🐳 Docker Compose setup completed!${NC}"
        echo -e "${CYAN}Run: docker-compose -f docker-compose.mobile.yml up -d${NC}"
        echo -e "${CYAN}Access: http://localhost:8080${NC}"
        
    else
        log "Kubernetes deployment mode selected"
        create_namespace
        deploy_mobile_dashboard
        configure_ingress
        setup_ssl
        setup_monitoring
        test_deployment
        setup_local_access
        generate_qr_code
        display_connection_info
    fi
    
    success "🌌 ∞ Ω ∞ Warp-Speed Mobile Deployment Complete! ∞ Ω ∞ 🌌"
}

# Handle script interruption
trap 'echo -e "\n${RED}Deployment interrupted by user${NC}"; exit 1' INT

# Check if running as source or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi